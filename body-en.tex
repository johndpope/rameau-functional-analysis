
\section{Introduction}
\label{sec:introduction}

\nota{Context}

In the past few years we have been developing Rameau, an open-source
system for automatic harmonic analysis \cite{kroger08:rameau}. Rameau,
as of the last update, had support for many different chord-labeling
algorithms, automatic identitication of non-chordal sonorities, basic
musicological functionality (such as cadence and voice crossing
detection), Lilypond \cite{nienhuys.ea08:lilypond} integration, tonal
codification support and many other interesting properties. Its source
code can be found in \url{http://genos.mus.br/rameau/}.

\nota{Focus}

Recently, we have implemented in Rameau support for roman numeral
functional harmonic analysis. This includes adding notions of
keyfinding, tonal function detection, modulation and tonicization
detection and some other secondary features. Supporting this analysis
involves many important musicological decisions, and has some
non-trivial consequences. For example, many tonal pieces have phrases
and even movements that are non-harmonical in nature, such as some
contrapuntual passages in Brahms' no 1 quartet \nota{confirmar, citar
  direito}. Every harmonic analysis of such a passage is nonsensical,
and, if automatically performed, will probably find cadences in the
noise instead of detecting the structure of the piece. Another
important problem is how to represent, internally, a roman numeral
functional analysis. How we approached these problems will be made
clear in the remainder of this paper.

\nota{Related work}

There are many published algorithms and systems for functional
harmonic analysis. Among the earliest ones are Winograd
\cite{winograd68:linguistics} and Ulrich's \cite{ulrich77:analysis}
works, both based on natural language parsing techniques. Maxwell
\cite{maxwell92:expert} has developed an expert system whose
functionality is currently under implementation in Rameau. The hidden
Markov model described in section \ref{sec:hidden-markov-model} is
loosely based on work by Raphael et
al. \cite{raphael.ea03:harmonic}. The neural networks we implement are
based on Tsui's master's thesis \cite{tsui02:harmonic}. Taube
\cite{taube99:automatic} has implemented a music theory workbench that
performs, among other activities, functional harmonic analysis
pattern-matching chords and tonalities. A good survey of the state of
the art of automated harmonic analysis circa 2001 can be found in the
work of Bathélemy et al. \cite{barthelemy.ea01:figured}.

\nota{contributions}

In this paper we present the infrastructure and algorithms implemented
in Rameau to properly do functional harmonic analysis, and the
problems encountered on the path.

\nota{structure}

\section{The problem}
\label{sec:problem}

Roman numeral functional analysis consists, roughly, in two
activities: key finding and roman numeral function detection. This
view, on the one hand, highlight the important factors for this
specific problem but, on the other hand, ignores important sub-aspects
of harmonic analysis such as the detection of harmonically significant
segments, the disambiguation of enharmonic notes, the disambiguation
of possibly different chord types (such as telling a major chord
without a third apart from a minor chord without a third).

\subsection{Key finding}
\label{sec:key-finding}

\nota{keyfinding é algo terrivelmente ambíguo, pode ter vários níveis
  de verdade}

The word ``key'', in tonal music theory, has many similar meanings,
and telling them apart is crucial when designing harmonic analysis
software. When speaking of key, a musician might speak of the key of a
piece, the key of a passage (a movement in a symphony, for example,
might have a different key from the main key in the symphony), the key
of a phrase, the key of a cadence, and even the key of a single chord
(for example, it might be argued that, for a secondary dominant chord,
its key might be said to be different from the overall key of the
surrounding passage). Clearly, there might be more or less different
scopes for the key of a song, and determining in which scope (or
scopes) to perform analysis. There's also the problem of determining
how correct the key an algorithm finds for a given chord is.

\nota{como mostrar o resultado}

Another important problem involving keyfinding is the graphical
representation of a key that is shown to the user.

\subsection{Roman function detection}
\label{sec:roman-funct-detect}

\nota{funções romanas dependem muito da tonalidade encontrada}

\nota{e dependem também das notas de forma sutil}

\section{The Framework}
\label{sec:framework}

\nota{gabarito}

The first, and arguably most important, implementation decision when
desigining the roman numeral functional analysis part of Rameau was
the internal format for representing a complete analysis of a
piece. As described in \cite{kroger08:rameau}, Rameau represents a
piece internally as a list of notes and, before analysis, converts it
into a list of sonorities (where a sonority is a set of notes sounding
at a given instant of time). Therefore, we chose the format for the
roman numeral functional analysis to be a list of instantaneous
analyzes. An instantaneous analysis is a snapshot of the analysis for
one sonority. Due to the key granularity problem described in section
\ref{sec:key-finding}, this snapshot only shows the most local
information possible. Later on we will extend this format to encompass
notions such as the overall key of a piece or a movement. Each such
snapshot is a tuple $(K,R)$, where $K$ is the key and $R$ is the roman
numeral analysis for that sonority under key $K$. Internally, a key is
a tuple $(P_k,M_k)$, where $P_k$ is the key's pitch and $M_k$ is the
key's mode (which can be major or minor). The roman function $R$ is
also a tuple $(N,A,M_r)$, where $N$ is the roman numeral (when
applicabble), $A$ is the number of sharps (of flats) on that numeral
and $M_r$ is the roman function's mode. For example, a minor flat
seventh chord in a $D$ major key is represented internally as
$((D,major),(vii,\flat,minor)$. While this representation has some
drawbacks, such as the impossibility of clearly marking non-harmonic
passages, it is extensible and practical for analysing simple
harmonies such as the Bach chorales.

\nota{conferir com resultados}

One of the goal of the Rameau project is understanding and comparing
previously published and new techniques for automatic harmonic
analysis. To properly compre harmonic analysis algorithms we have a
corpus of 371 Bach chorales from the Riemenschneider edition
\cite{bach41:371}, 20 of them annotated by experts with an acceptable
harmonic analysis. Rameau includes facilities to train machine
learning algorithms on these analyzed chorales and a bayesian
framework for estimating the correctness of the expert annotations and
using this estimate to derive confidence intervals for the accuracies
of the algorithms \nota{citar monografia?}. The analysis results can
also be neatly typeset with the aid of the Lilypond music typesetting
program \cite{nienhuys.ea08:lilypond}.

\section{Algorithms}
\label{sec:algorithms}

Using the infrastructure described in section \ref{sec:framework}
Rameau currently has implementations of four different roman numeral
functional analysis; a hidden Markov model, a k-nearest neighbors
classifier and a trivial extension of Pardo \& Birmingham's chord
labeling algorithm \cite{pardo.ea99:automated}.

\subsection{Hidden Markov Model}
\label{sec:hidden-markov-model}

A hidden Markov model is any probabilistic function of a Markov
chain. Using a hidden Markov model to perform roman numeral function
analysis consists of modeling the notes in a tonal piece as a
probabilistic function of the underlying harmonies, and finding these
harmonies, given the notes, using traditional hidden Markov model
algorithms. Our approach closely follows that of Raphael and Stoddard
\cite{raphael.ea03:harmonic}, and the differences will be noted here.

The underlying Markov chain is assumed to be from a pair $(K,R)$ (as
described in section \ref{sec:framework}) to another such
pair. Internally, though, this transition table is compressed assuming
some invariances (without this compression we would need around $10^9$
entries in it). The only invariance we assume is that transposing the
music to another key with the same mode should not change its
analysis. The notes found in the actual piece are assumed to be
independently and identically drawn from a distribution particular to
each possible key and roman function. This table is also compressed
assuming a transposition invariance on the key pitch. 

A good way to see how much of the underlying structure of a process is
captured by a hidden Markov model is by analysing samples from the
model. Figure \ref{fig:amostra} shows such a sample. As it can be
seen, the Markov model has no concept of voice leading and is quite
liberal in using non-chord tones. The line marked as ``Original''
shows the undelying state sequence used by the hidden Markov model to
generate this piece. The line labeled ``HMM Analysis'' is an analysis
of the same piece by the HMM. It already corrects some misconceptions
of the generating model about chord structure. Finally, the line
labeled ``Correct Analysis'' shows the best a human expert could do to
understand the underlying harmony of this piece. This sample also
shows an important flaw of this technique, which is the high prior
probability given to a piece that ends in an entirely different key
from the one in which it started. Perhaps some notion of a ``global''
or ``underlying'' key might improve the performance of this algorithm.

\begin{figure*}[t]
  \centering
  \includegraphics[trim=0cm 5cm 0cm 2.5cm]{amostra-markov}
  \caption{A sample from the hidden Markov model}
  \label{fig:amostra}
\end{figure*}

\subsection{K-Nearest Neighbors}
\label{sec:knn}

\begin{algorithm}[t]
  \SetLine
  \KwIn{$x$, an instance to be classified}
  $nearest = nil$\;
  $distance = \inf$\;
  \For{each example $e$}{
    \If{$d(e,x) < distance$}{
      $nearest = e$\;
      $distance = d(e,x)$\;
    }
  }
  \KwRet{$class(nearest)$}\;
  \caption{A nearest neighbor classifier (a knn for $k=1$).}
  \label{alg:knn}
\end{algorithm}

A tool used in machine learning for many non-trivial tasks is the
k-nearest neighbors classifier \cite{mitchell97:machine}. It works by
first representing the instances to be classified in some metric
space. Then, to classify an instance $x$, the knn algorithm chooses,
from the training data set, the set $s$ of the $k$ closest examples to
$x$ and outputs the most common class in $s$. For the case of $k=1$,
algorithm \ref{alg:knn} describes the main idea.

To apply a knn classifier in roman numeral functional analysis first
we need to choose a spatial representation of a segment of a piece,
describe and appropriate distance function and choose a training
set. The representation we chose for Rameau is a pitch frequency array
$a$, in which, if $f*n$ on the $n$ pitches in a given sonority are
encoded (is some codification such as pitch-class or the one described
in \cite{kroger08:rameau}) as having number $p$, then $a[p] = f$. When
considering surrounding context, we concatenate these arrays and, to
avoid adding too much noise in the distance function we weight them
down in proportion to the square of the distance between the
contextual sonority and the sonority being analyzed. Then, we can use
the simple euclidean distance function $d(a,b) = ||a-b||$.

\subsection{Pardo \& Birmingham's}
\label{sec:pardo--birminghams}

Pardo \& Birmingham \cite{pardo.ea99:automated} describes an algorithm
for chord labeling that has some predefined chord templates and
chooses among them the one that most closely matches the notes
sounding in a given sonority. Table \ref{tab:templates-pardo} shows
the templates used in this work.

To extend the original algorithm to perform roman numeral functional
analysis we chose not to perform any non-trivial modifications, since
those would warrant another algorithm in and of themselves. Therefore,
we simply created the key for the whole piece using the root and mode
of the first chord found by Pardo \& Birmingham's algorithm, and
thus computed the roman numeral function for all other chords in that
key. While simplistic, this approach performs almost competitively
with the hidden Markov model.

\begin{table}[h]
  \centering
  \begin{small}
    \begin{sc}
      \begin{tabular}[t]{ll} \hline
        Chord type & Notes (counting from c) \\ \hline
        Major triad & c e g \\
        Major-minor chord &  c e g b$\flat$ \\
        Minor triad & c e$\flat$ g \\
        Minor-minor chord & c $e\flat$ g b$\flat$ \\
        Fully diminished chord & c e$\flat$ g$\flat$ b$\flat\flat$ \\
        Half-diminished chord & c e$\flat$ g$\flat$ b$\flat$ \\
        Diminished triad & c e$\flat$ g$\flat$ \\
        Major-major chord & c e g b \\
        Augmented triad & c e g$\sharp$ \\
        German sixth  & c e g a$\sharp$ \\
        Italian sixth & c e a$\sharp$ \\
        French sixth & c e f$\sharp$ a$\sharp$ \\ \hline
      \end{tabular}
    \end{sc}
  \end{small}
  \caption{Templates for the Pardo \& Birmingham algorithm.}
  \label{tab:templates-pardo}
\end{table}

\section{Example analyses}
\label{sec:example-analyses}

\section{Conclusions and future work}
\label{sec:concl-future-work}

While still preliminary, the current implementation of functional
harmonic analysis in Rameau is promissory, and already has good
results. Rameau is open source, written in Common Lisp and its source
code (together with our data sets and instructions on how to compile,
install and run it) are available at
\url{http://genos.mus.br/rameau/}.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "icmc2009"
%%% End: 
