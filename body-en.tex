
\section{Introduction}
\label{sec:introduction}

In the past few years we have been developing Rameau, an open-source
system for automatic harmonic analysis\footnote{The reference was
  removed for anonymity and will be added in the final
  version.}. Rameau, as of the last update, had support for many
different chord-labeling algorithms, automatic identification of
non-chordal sonorities, basic musicological functionality (such as
cadence and voice crossing detection), reading and writing Lilypond
\cite{nienhuys.ea08:lilypond} files, tonal codification support and
many other interesting properties. Its source code can be found in
\url{http://removed/for/anonymity/}.

Recently, we have implemented support for roman numeral analysis in
Rameau. This support includes the addition of key finding algorithms,
the detection of tonal functions, modulation, and tonicization, and
some other secondary features. Supporting this analysis involves many
important musicological decisions, and has some non-trivial
consequences. For example, some tonal pieces have passages with a more
contrapuntal nature. Every harmonic analysis of such passage is
nonsensical, and, if automatically performed, will probably find
cadences where there are none, instead of detecting the structure of
the piece.  Another important problem is how to represent, internally,
a roman numeral functional analysis. We will make clear in the
remainder of this paper how we approached these problems.

There are many published algorithms and systems for functional
harmonic analysis. Among the earliest ones are Winograd's
\cite{winograd68:linguistics} and Ulrich's \cite{ulrich77:analysis}
works, both based on natural language parsing techniques. Maxwell
\cite{maxwell92:expert} has developed an expert system whose
functionality is currently under implementation in Rameau. The hidden
Markov model described in section \ref{sec:hidden-markov-model} is
loosely based on work by Raphael et
al. \cite{raphael.ea03:harmonic}. In Rameau there are some neural
network algorithms, loosely based on Tsui's master's thesis
\cite{tsui02:harmonic}. Taube \cite{taube99:automatic} has implemented
a music theory workbench that performs, among other activities,
functional harmonic analysis pattern-matching chords and tonalities. A
good survey of the state of the art of automated harmonic analysis
circa 2001 can be found in the work of Bath√©lemy et
al. \cite{barthelemy.ea01:figured}.

In this paper we present the infrastructure and algorithms implemented
in Rameau to properly do functional harmonic analysis, and the
problems encountered along the way.

Section \ref{sec:problem} gives an overview of the general problems
encountered in automating functional harmonic analysis using roman
numerals. Section \ref{sec:framework} describes some implementation
decisions in Rameau that attempt to go around those problems. Section
\ref{sec:algorithms} describes superficially each algorithm currently
implemented in Rameau. Typical analyses are shown in section
\ref{sec:example-analyses}, together with some comments on relative
algorithm performance. Section \ref{sec:concl-future-work} contains
some concluding remarks and directions for future work.

\section{The problem}
\label{sec:problem}

Roman numeral functional analysis consists, roughly, in two
activities: key finding---determining what is the tonal center of the
piece and its parts---and roman numeral function
detection---determining the tonal function of each segment of the piece. 

While this division highlights the important factors for this specific
problem it, on the other hand, ignores important sub-aspects of
harmonic analysis such as the detection of harmonically significant
segments, the disambiguation of enharmonic notes, the disambiguation
of possibly different chord types, such as telling a major chord
without a third apart from a minor chord without a third.

\subsection{Key finding}
\label{sec:key-finding}

The word ``key'', in tonal music theory, has many similar meanings,
and telling them apart is crucial when designing harmonic analysis
software. When speaking of key, a musician might speak of the key of a
piece, the key of a passage (a movement in a symphony, for example,
might have a different key from the main key in the symphony), the key
of a phrase, the key of a cadence, and even the key of a single
chord---for example, it might be argued that, for a secondary dominant
chord, its key might be said to be different from the overall key of
the surrounding passage. Clearly, there might be more or less
different scopes for the key of a song, and determining in which scope
(or scopes) to perform analysis. Another difficulty of implementing a
key finding algorithm is that there is no clear way of determining the
correctness for a key an algorithm finds for a given chord.

Another important problem involving key finding is the graphical
representation of a key that is shown to the user.

\subsection{Roman function detection}
\label{sec:roman-funct-detect}

Detecting the roman function of a segment of a piece, even after
determining its key, is also a naturally ambiguous problem. Even
defining what are the possible roman functions is not an easy problem.
For example, one might want to consider Naepolitan sixths as a roman
function, or a german augmented sixth chord, even if neither of these
is technically built from triads in the given key. Also, important
notes in a tonal function can be ommitted from the passage having that
function, and this is often done purposefully by the compose to enrich
the passage \cite{schoenberg83:theory}.


\section{The Framework}
\label{sec:framework}

The first, and arguably most important, implementation decision when
desigining the roman numeral functional analysis part of Rameau was
the internal format for representing a complete analysis of a piece.
As described in\footnote{This reference was also removed for
  anonymity reasons, and will be present in the final paper.}, Rameau
represents a piece internally as a list of notes and, before analysis,
converts it into a list of sonorities, where a sonority is a set of
notes sounding at a given instant of time. Therefore, we chose the
format for the roman numeral functional analysis to be a list of
instantaneous analyses, where an instantaneous analysis is a snapshot
of the analysis for one sonority of a song. Due to the key granularity
problem described in section \ref{sec:key-finding}, this snapshot only
shows the most local information possible. Later on we will extend
this format to encompass notions such as the overall key of a piece or
a movement. Each such snapshot is a tuple $(K,R)$, where $K$ is the
key and $R$ is the roman numeral analysis for that sonority under key
$K$. Internally, a key is a tuple $(P_k,M_k)$, where $P_k$ is the
key's pitch and $M_k$ is the key's mode (which can be major or minor).
The roman function $R$ is also a tuple $(N,A,M_r)$, where $N$ is the
roman numeral (when applicabble), $A$ is the number of sharps (of
flats) on that numeral and $M_r$ is the roman function's mode. For
example, a minor flat seventh chord in a $D$ major key is represented
internally as $((D,major),(vii,\flat,minor)$. While this
representation has some drawbacks, such as the impossibility of
clearly marking non-harmonic passages, it is extensible and practical
for analysing simple harmonies and textures such as the Bach
chorales.

One of the goals of the Rameau project to understand and compare
previously published and new techniques for automatic harmonic
analysis. To properly compare harmonic analysis algorithms we have a
corpus of 371 Bach chorales from the Riemenschneider edition
\cite{bach41:371}, 20 of them annotated by experts with an acceptable
harmonic analysis. Rameau includes facilities to train machine
learning algorithms on these analyzed chorales and a bayesian
framework for estimating the correctness of the expert annotations and
using this estimate to derive confidence intervals for the accuracies
of the algorithms\footnote{A reference for this result was removed for
  anonymity.}. The analysis results can also be neatly typeset with
the aid of the Lilypond music typesetting program
\cite{nienhuys.ea08:lilypond}.

\section{Algorithms}
\label{sec:algorithms}

Using the infrastructure described in section \ref{sec:framework}
Rameau currently has implementations of four different roman numeral
functional analysis; a hidden Markov model, a k-nearest neighbors
classifier, a neural network-based harmonic analyzer similar to the
one described by Tsui \cite{tsui02:harmonic}, and a trivial extension
of Pardo \& Birmingham's chord labeling algorithm
\cite{pardo.ea99:automated}.

\subsection{Hidden Markov Model}
\label{sec:hidden-markov-model}

A hidden Markov model is any probabilistic function of a Markov
chain. Using a hidden Markov model to perform roman numeral function
analysis consists of modeling the notes in a tonal piece as a
probabilistic function of the underlying harmonies, and finding these
harmonies, given the notes, using traditional hidden Markov model
algorithms. Our approach closely follows that of Raphael and Stoddard
\cite{raphael.ea03:harmonic}, and the differences will be noted here.

The underlying Markov chain is assumed to be from a pair $(K,R)$ (as
described in section \ref{sec:framework}) to another such
pair. Internally, though, this transition table is compressed assuming
some invariances (without this compression we would need around $10^9$
entries in it). The only invariance we assume is that transposing the
music to another key with the same mode should not change its
analysis. The notes found in the actual piece are assumed to be
independently and identically drawn from a distribution particular to
each possible key and roman function. This table is also compressed
assuming a transposition invariance on the key pitch. 

A good way to see how much of the underlying structure of a process is
captured by a hidden Markov model is by analysing samples from the
model. Figure \ref{fig:amostra} shows such a sample. As we can see,
the Markov model has no concept of voice leading and is quite liberal
in using non-chord tones. The line marked as ``Original'' shows the
undelying state sequence used by the hidden Markov model to generate
this piece. The line labeled ``HMM Analysis'' is an analysis of the
same piece by the HMM. It already corrects some misconceptions of the
generating model about chord structure. Finally, the line labeled
``Correct Analysis'' shows the best a human expert could do to
understand the underlying harmony of this piece. This sample also
shows an important flaw of this technique, which is the high prior
probability given to a piece that ends in an entirely different key
from the one in which it started. Perhaps some notion of a ``global''
or ``underlying'' key might improve the performance of this algorithm.

\begin{figure*}[t]
  \centering
  \includegraphics[scale=.85,trim=0cm 5cm 0cm 2.5cm]{amostra-markov}
  \caption{A sample from the hidden Markov model}
  \label{fig:amostra}
\end{figure*}

\subsection{K-Nearest Neighbors}
\label{sec:knn}

\begin{algorithm}[t]
  \SetLine
  \KwIn{$x$, an instance to be classified}
  $nearest = nil$\;
  $distance = \infty$\;
  \For{each example $e$}{
    \If{$d(e,x) < distance$}{
      $nearest = e$\;
      $distance = d(e,x)$\;
    }
  }
  \KwRet{$class(nearest)$}\;
  \caption{A nearest neighbor classifier (a knn for $k=1$).}
  \label{alg:knn}
\end{algorithm}

A tool used in machine learning for many non-trivial tasks is the
k-nearest neighbors classifier \cite{mitchell97:machine}. It works by
first representing the instances to be classified in some metric
space. Then, to classify an instance $x$, the knn algorithm chooses,
from the training data set, the set $s$ of the $k$ closest examples to
$x$ and outputs the most common class in $s$. For the case of $k=1$,
algorithm \ref{alg:knn} describes the main idea.

To apply a knn classifier in roman numeral functional analysis first
we need to choose a spatial representation of a segment of a piece,
describe an appropriate distance function, and choose a training
set. The representation we chose for Rameau is a pitch frequency array
$a$, in which, if $f*n$ on the $n$ pitches in a given sonority are
encoded (is some codification such as pitch-class or the one described
in\footnote{The reference to the original paper was removed for
  anonymity reasons.}) as having number $p$, then $a[p] = f$. When
considering surrounding context, we concatenate these arrays and, to
avoid adding too much noise in the distance function we weight them
down in proportion to the square of the distance between the
contextual sonority and the sonority being analyzed. Then, we can use
the simple euclidean distance function $d(a,b) = ||a-b||$.

\subsection{Pardo \& Birmingham's}
\label{sec:pardo--birminghams}

Pardo \& Birmingham \cite{pardo.ea99:automated} describes an algorithm
for chord labeling that has some predefined chord templates and
chooses among them the one that most closely matches the notes
sounding in a given sonority. Table \ref{tab:templates-pardo} shows
the templates used in this work.

To extend the original algorithm to perform roman numeral functional
analysis we chose not to perform any non-trivial modifications, since
those would warrant another algorithm in and of themselves. Therefore,
we simply created the key for the whole piece using the root and mode
of the first chord found by Pardo \& Birmingham's algorithm, and
thus computed the roman numeral function for all other chords in that
key. While simplistic, this approach performs almost competitively
with the hidden Markov model.

\begin{table}[h]
  \centering
  \begin{small}
    \begin{sc}
      \begin{tabular}[t]{ll} \hline
        Chord type & Notes (counting from c) \\ \hline
        Major triad & c e g \\
        Major-minor chord &  c e g b$\flat$ \\
        Minor triad & c e$\flat$ g \\
        Minor-minor chord & c $e\flat$ g b$\flat$ \\
        Fully diminished chord & c e$\flat$ g$\flat$ b$\flat\flat$ \\
        Half-diminished chord & c e$\flat$ g$\flat$ b$\flat$ \\
        Diminished triad & c e$\flat$ g$\flat$ \\
        Major-major chord & c e g b \\
        Augmented triad & c e g$\sharp$ \\
        German sixth  & c e g a$\sharp$ \\
        Italian sixth & c e a$\sharp$ \\
        French sixth & c e f$\sharp$ a$\sharp$ \\ \hline
      \end{tabular}
    \end{sc}
  \end{small}
  \caption{Templates for the Pardo \& Birmingham algorithm.}
  \label{tab:templates-pardo}
\end{table}

\section{Example analyses}
\label{sec:example-analyses}

\begin{figure*}[t]
  \centering
  \includegraphics[scale=.85,trim=0cm 4cm 0cm 1.5cm]{exemplo-01}
  \caption{An excerpt of the analysis of Bach chorale \#20.}
  \label{fig:ex01}
\end{figure*}

An example of the results of the functional analysis process is shown
is figure \ref{fig:ex01}. Each line of text under the score shows the
results for an algorithm, and the line marked ``Answer'' shows a
hand-crafted answer sheet for this passage.

\section{Conclusions and future work}
\label{sec:concl-future-work}

While still preliminary, the current implementation of functional
harmonic analysis in Rameau is promising, and already has good
results. Rameau has implementations of a hidden Markov model, a
K-nearest neighbors, Pardo \& Birmingham's, and neural networks
functional harmonic analysis algorithms. Rameau is open source,
written in Common Lisp and its source code (together with our data
sets and instructions on how to compile, install and run it) is
available at \url{http://removed/for/anonymity/}.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "icmc2009"
%%% End: 
